import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class dfsbfs {
	static int [][] Dgraph =new int[1001][1001];
	static int [][] Bgraph =new int[1001][1001];
	static boolean[] visited =new boolean[10001];
	static int N;
	

	public static void main(String[] args) throws IOException {
		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=new StringTokenizer(bf.readLine());
		N=Integer.parseInt(st.nextToken()); //정점개수
		int M = Integer.parseInt(st.nextToken());	//간선개수
		int V = Integer.parseInt(st.nextToken());	//시작정점
		
		
		for(int i=0; i<M; i++) {
			st=new StringTokenizer(bf.readLine());
			int x=Integer.parseInt(st.nextToken());
			int y=Integer.parseInt(st.nextToken());
			Dgraph[x][y] = Dgraph[y][x] = 1; //양방향일수도 있어서 이렇게 한다.
			Bgraph[x][y] = Bgraph[y][x] = 1;
			
		}
		
		DFS(V);
		System.out.println();
		BFS(V);
		}
		
	public	static void DFS(int n) {//시작점을 변수로 받아 확인후 다음연결점을 찾아 시작점 변경		
		visited[n] =true;
		System.out.print(n+" ");
		
		for(int i=1; i<=N; i++) {
			if(!visited[i] && Dgraph[n][i]==1) {
					DFS(i);
			}
		}
	}
	
	public static void BFS(int n ) {
		boolean [] visited = new boolean[1001];
		Queue<Integer> q=new LinkedList<Integer>();
		visited[n] = true; //시작노드 true로
		q.offer(n); //큐에 1추가 초기 상태의 큐에는 시작 노드만이 저장
		
		while (!q.isEmpty()) {	//queue.size() !=0	
			int p = q.poll();	//큐1을 반환하여 방문 
			System.out.print(p+" ");	
			
				for(int i=1;i<=N;i++) { //꼭짓점 개수까지 반복
					if(!visited[i] && Bgraph[p][i]==1) { //방문x and 큐에서 꺼낸 인접한 노드 모두 방문 인접노드 없으면 큐의 앞에서 노드꺼냄 
							visited[i]=true; 
							q.offer(i); //큐에 방문된 노드를 삽입
					}//큐가 공백 상태일때까지 반복
				}
		
		}
	
	}
		
		
		
		
		
		
}

